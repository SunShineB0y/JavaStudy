## 栈

### 栈的定义

栈(Stack)是仅限定在表尾进行插入或删除操作的线性表。表尾端称为栈顶，表头端称为栈底。不含元素的空表称为空栈。

栈的修改是按照后进先出的原则进行的，因此，栈又称为**后进先出**的线性表（简称LIFO结构）。


### 栈的结构示意图

![](https://i.imgur.com/U81T0vX.jpg)


###  栈的基本操作
- InitStack(&S)：构造一个空栈S
- DestoryStack(&S)：销毁栈S
- ClearStack(&S)：若S栈已存在，将栈清空
- StackEmpty(S)：S栈已存在时，若S栈为空栈，则返回true，否则返回false
- StackLength(S)：栈S已存在时，返回元素的个数，即栈的长度
- GetTop(S,&e)：栈S已存在且非空时，用e返回S的栈顶元素。
- Push(&S,e):栈S已存在时，插入e为新的栈顶元素
- Pop(&S,&e)：栈S已存在且非空时，删除S的栈顶元素，并用e返回其值
- StackTraverse(S,visit())：栈S已存在且非空时，从栈底到栈顶依次对S的每个数据元素调用函数visit()。一旦vist()失败，则操作失败。

### 栈的表示和实现
栈有顺序栈和链栈两种表示。顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放栈底到栈顶的数据元素，同时附有指针top指示栈顶元素在顺序栈中的位置，top = 0则表示空栈。
> 一般来说，在初始化设空栈时不应限定栈的最大容量。较合理的做法是：先为栈分配一个基本容量，然后在应用过程中，当栈的空间不够使用时再扩大。

顺序栈的定义

    typedef struct{
		SElemType *base;
		SElemType *top;
		int stacksize;
	}SqStack; 
	
栈的初始化操作为：按设定的初始分配量进行第一次存储分配，base可称为栈底指针，在顺序栈中，它始终指向栈底的位置，若base的值为NULL，则表明栈结构不存在。称top为栈顶指针，其初值指向栈底，即top = base可作为栈空的标记，每当插入新的栈顶元素时，指针top增1；删除栈顶元素时，指针top减1，因此，非空栈中的栈顶指针始终在栈顶元素的下一个位置上。


### 栈与递归的实现
栈的一个很重要的应用是在程序设计语言中实现**递归**。常见的用递归求解的问题有八皇后问题、Hanoi塔问题等。
> 一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称为递归函数。


## 队列

### 队列的定义
队列是一种**先入先出**（first in first out，缩写为FIFO）的线性表，它只允许在表的一端进行插入，而在表的另一端删除元素。在队列中，允许插入的一端叫做队尾（rear），允许删除的一端称为对头(front)。

### 队列的结构示意图

![](https://i.imgur.com/wq1JEHd.jpg)

### 队列的基本操作
- InitQueue(&Q)：构造一个空队列Q
- DestoryQueue(&Q)：销毁队列Q
- ClearQueue(&Q)：若Q队列已存在，将队列清空
- QueueEmpty(Q)：Q队列已存在时，若Q队列为空队列，则返回true，否则返回false
- QueueLength(Q)：Q队列已存在时，返回元素的个数，即队列的长度
- GetHead(Q,&e)：队列Q已存在且非空时，用e返回Q的对头元素。
- EnQueue(&Q,e):队列Q已存在时，插入e为新的队尾元素
- DeQueue(&Q,&e)：队列Q已存在且非空时，删除Q的队头元素，并用e返回其值
- QueueTraverse(Q,visit())：队列Q已存在且非空时，从队头到队尾依次对Q 的每个数据元素调用函数visit()。一旦vist()失败，则操作失败。

## 串

### 串的定义
串（string）（或字符串）是由零个或多个字符组成的有限序列，一般记为`s = 'a1a2...an' (n>=0)`，s是串的名，用单引号括起来的字符序列是串的值，ai可以是字母、数字或其他字符。字符的数目就是串的长度。零个字符的串称为空串。

串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串称为主串。由一个或多个空格组成的串' '称为空格串，它的长度为串中空格字符的个数。

称两个串是相等的，只有当两个串的长度相等，并且各个对应位置的字符都相等是才相等。 


### 串的表示和实现

1. 定长顺序存储表示

类似于线性表的顺序存储结构，用一组连续的存储单元存储串值的字符序列，按照定义的大小，为每个定义的串变量分配一个固定长度的存储区。

	// 串的定长顺序存储表示
	#define MAXSTRLEN 255 //用户可以在255内定义最大串长
	typedef unsigned char SString[MAXSTRLEN + 1] //0号单元存放串的长度

2. 堆分配存储表示

这种存储表示的特点是，仍以一组地址连续的存储单元存放串值序列，但它们的存储空间是在程序执行过程中动态分配而得。

	// 串的堆分配存储表示
	typedef struct {
		char *ch; //若是非空串，则按串长分配存储区，否则ch为NULL
		int length; //串长度
	}HString
	
	
## 线性表
线性表是最常用且最简单的一种数据结构。一个线性表是n个数据元素的有限序列。

在稍复杂的线性表中，一个数据元素可以由若干个 **数据项**（item）组成。在这种情况下，常把数据元素称为 **记录**（record），含有大量记录的线性表又称为 **文件**（file）。

线性表中元素的个数n（n>=0）定义为线性表的长度，n = 0 时称为空表。线性表的长度可以根据需要增长或缩短，即对线性表的数据元素不仅可以进行访问，还可以进行插入和删除等。


### 线性表的顺序表示和实现
线性表的顺序表示指的是用用一组连续的存储单元依次存储线性表的数据元素。

	// 线性表的动态分配顺序存储结构
	#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量
	#define LISTINCREMENT 10 //分配增量
	typedef struct{
	ElemType *elem; //存储空间基址
	int length; //当前长度
	int listsize; //当前分配的存储容量
	}

数组指针elem指示线性表的基地址，length指示线性表的当前长度。在这种存储结构中，插入或删除新元素时，都需要移动插入或删除位置的元素后面的元素的位置。
