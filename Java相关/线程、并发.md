## 进程与线程

进程是获取资源的基本单位，且进程之间是隔离的，想要共享资源会非常麻烦。进程是重量级的，而线程是轻量级的。所谓线程，就是程序代码的运行。线程是供CPU调度的基本单位。线程只是进程的代码片段，一个进程可以包含多个线程。Java的虚拟机JVM就是一个进程。

## 线程与线程池

虽然线程是个轻量级的东西， 但是对于互联网应用来说，如果每个用户的请求都创建一个线程，那会非常得多，服务器也是难于承受， 再说了，众多的线程去竞争CPU，不断切换，也会让CPU调度不堪重负，很多线程将不得不等待。所以前辈们的思路就是（1）用少量的线程 （2） 让线程保持忙碌。

就是说只创建一定数量的线程，让这些线程去处理所有的任务，任务执行完了以后，线程并不结束，而是回到线程池中去，等待接受下一个任务。

线程可以预先创建出来，并让线程进入阻塞状态，这样任务来了就不需要临时创建线程，可以直接提供服务。

## 线程创建的方法
先写两种，后续再补充

1. 继承Thread类，重写run( )方法。

		Thread thread ＝ new Thread()； 

2. 线程实现Runable接口，重写run( )方法。创建Runable类实例，并以此实例作为Thread的target来创建Thread对象。

		Runable myRunable ＝new Runable()；
		Thread thread ＝new Thread(myRunable)；
		
3. 实现Callable接口通过FutureTask包装器来创建Thread线程 
  
## 线程的生命周期

1. 新建状态  new Thread( )的时候。
2. 就绪状态 当线程调用start( )方法时，该线程进入就绪状态
3. 运行状态  处于就绪状态的线程，被CPU调用，并开始执行run( )方法时，线程进入运行状态，此时线程才开始真正运行。
4. 阻塞状态  处于运行状态的线程，由于某种原因暂时失去了对CPU的使用权(可能是失去了执行所必须的资源或者请求不到所需的资源)，停止了执行，此时线程进入阻塞状态。
5. 死亡状态  当线程run( )方法执行完或因异常退出了run( )方法时，该线程结束生命周期。

## wait()，sleep()，yield()的区别

- wait()用于线程间通信用的，定义在Object类中，会释放当前对象锁，只能在同步(synchronized)环境中使用。
- sleep()用于短时间暂停当前线程，定义在Thread类中，不会释放当前锁。
- yield()方法仅释放当前CPU资源，让给同优先级或优先级更高的线程执行。有些时候调用yield()方法的线程可能会再次得到CPU资源，不能达到让步操作。

## 如何停止一个正在运行的线程？
1. 使用退出标志，使线程正常退出，也就是当线程run()方法完成后线程终止。
2. 使用stop方法强行终止，不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。
3. 使用interrupt方法中断线程。

## 线程池
Executors提供了四种方法创建线程

1. newFixedThreadPool()：创建固定大小的线程池
2. newCachedThreadPool()：创建无限大小的线程池，线程池中线程数量不固定，可根据需求自动修改
3. newSingleThreadPool()：创建单个线程池，线程池中只有一个线程。
4. newScheduledThreadPool():创建固定大小的线程池，可以延时或定时的执行任务

### 线程池作用
1. 限制线程个数，避免线程过多导致系统运行缓慢或崩溃
2. 不需要频繁地创建和销毁，节约资源、响应更快。

