##  1.Hashset如何检查重复

当把对象插入Hashset时，Hashset会先计算对象的hashcode值来判断对象加入的位置，同时也会与Hashset中其他对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。

hashcode( )与equals( )的相关规定

1. 如果两个对象相等，则hashcode一定也是相同的
2. 两个对象相等,对两个equals方法返回true
3. 两个对象有相同的hashcode值，它们也不一定是相等的
4. 综上，equals方法被覆盖过，则hashCode方法也必须被覆盖
5. hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。

==与equals的区别

1. ==是判断两个对象或实例是不是指向同一个内存空间，equals是判断两个对象或实例所指的内存空间的值是不是相等
2. ==是对内存地址进行比较，equals是对字符串的内容进行比较
3. ==指引用是否相同，equals指值是否相同

## 2.Hashset与Hashmap的区别
Hashset实现了Set接口，是一个存储对象的集合，它底层使用Hashmap实现的，Hashset不允许元素重复，调用add( )方法添加元素，不允许元素为null,它的效率比Hashmap高。Hashset不是线程安全的。

Hashmap实现了Map接口，它是一个存储KEY-VALUE键值对的数组，允许KEY或VALUE为null,但只允许一个KEY为null，它调用put("KEY",VALUE)的方法添加元素，会把KEY为null的Entry在Hashmap数组的第一个位置。Hashmap也不是线程安全的，需要保证线程安全时建议使用conCurrentHashMap,而不是Hashtable!(Hashtable虽能保证线程安全，但效率比conCurrentHashMap低太多，基本已经没人使用了)
