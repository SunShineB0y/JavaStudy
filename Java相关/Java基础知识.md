## 1.Java面向对象编程的特性 ##
**封装**

封装是把对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。

**继承**

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

**需要注意的有：**

1. 用final关键字修饰的类不能被继承
2. 父类私有的属性和方法不能被继承
3. 子类可以拥有自己的属性和方法
4. 子类可以用自己的方式实现父类的方法

**多态**

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

Java中实现多态的两种方式：**继承**（多个子类对同一方法的重写）和**接口**（实现接口并覆盖接口中同一方法）。

**抽象**

把现实生活中的对象抽象为类，分成过程抽象和数据抽象

- 过程抽象：鸟有翅膀，羽毛等，抽象为鸟类的属性
- 数据抽象：鸟会飞，会叫，抽象为鸟类的方法


## 2.JDK、JRE和JVM三者之间的联系和区别 ##
**JDK：**
它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。

**JRE:**
普通用户而只需要安装 JRE（Java Runtime Environment）来运行 Java 程序。而程序开发者必须安装JDK来编译、调试程序。

**JVM:**
Java虚拟机，java.exe运行起来就是虚拟机，是一个进程。当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理、垃圾回收和安全机制等。JVM可以屏蔽操作系统的差异，使Java编写的程序独立于硬件和操作系统，使任何可以支持该虚拟机的操作系统都可以运行Java程序，实现“一次编码，到处运行”。

**区别和联系**

1. JDK用于开发，JRE用于运行,JDK包含了JRE
2. JDK和JRE都包含了JVM
3. JVM是Java语言的核心并且具有平台独立性。


## 3.方法重写和重载的区别
1. 重载发生在同一个类中，重载要求方法名相同，返回值类型和访问修饰符可以不同，参数个数、类型、顺序可以不同。
2. 重写发生在父子类中，子类重写父类的方法，方法名和参数列表必须相同，子类方法访问修饰符大于等于父类，子类方法返回值类型和抛出异常的范围小于等于父类。子类不能重写父类的私有方法。

## 4.Java和C＋＋的区别

1. 都是面向对象的语言，都支持封装，继承，多态。
2. C＋＋是多继承的，一个类可以继承多个类。
Java是单继承的，但在Java中接口可以多继承。
3. Java不提供指针来直接访问内存，程序内存更加安全。
4. Java有自动内存管理机制，不需要人为释放无用内存。

## 5.this，super关键字

1. this关键字用于引用类的当前实例
2. super关键字用于从子类访问父类的方法或属性

使用this和super要注意的问题

- super 调用父类中的其他构造方法时，调用时要放在构造方法的首行。this 调用本类中的其他构造方法时，也要放在首行。

- this和super不能用在static方法中

被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。

## 6.final，static关键字

final关键字可以用于修饰类、常量和方法

1. final修饰类，此类不可以被继承，类中所有的成员方法被隐式指定为final方法
2. final修饰变量，如果该变量是基本数据类型的，则该变量的值在初始化后不能修改；如果是引用类型的变量，则在初始化不能让其指向另一个对象。
3. 使用final修饰方法的原因:一是把方法锁定，防止继承类修改它的含义；第二是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。

static关键字主要有以下几种使用场景

1.修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式： ` 类名.静态变量名 类名.静态方法名() ` 

2.静态代码块:静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.

3.静态内部类（static修饰类的话只能修饰内部类）：静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法

4.静态导包(用来引入类中的静态资源)格式为： `import static ` 两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

## 7.instance of关键字
instance of 通过返回一个布尔类型的值来判断一个对象是否是这个特定类或者其子类的实例。

## 8.String、StringBuilder、StringBuffer三者的区别
1. String使用final关键字修饰的字符数组保存字符串，`private final char value[]`，所以String对象是不可变的。每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。

	StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[] value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。StringBuffer 和StringBuilder每次都会对字符串对象本身进行操作，而不是生成新的对象并改变对象引用。
1. String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 

**总结：**
		
1. 操作少量数据：String
2. 单线程字符缓冲区下操作大量数据：StringBuilder
3. 多线程字符缓冲区下操作大量数据：StringBuffer

## 9.自动装箱与拆箱
1. 装箱：将基本数据类型用它们对应的引用类型包装起来。
2. 拆箱：将包装类型转变为基本数据类型。

## 10.字符型常量和字符串常量的区别
1. 形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符
2. 含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)
3. 占内存大小：字符常量只占2个字节 字符串常量占若干个字节(至少一个字符结束标志) (注意： char在Java中占两个字节)

## 11.成员变量和局部变量的区别
1. 成员变量是属于类的，局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰；
2. 从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存；
3. 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被 final 修饰但没有被 static 修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。

## 12.构造方法有什么特性
1. 方法名与类名相同；
2. 没有返回值，但不能用void声明构造函数；
3. 生成类的对象时自动执行，无需调用。

## 13.在 Java 中定义一个不做事且没有参数的构造方法的作用
Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类的无参构造方法。如果父类没有无参的构造方法，子类的构造方法又没有用`super`调用父类特定的构造方法，则会在编译时发生错误。解决方法是在父类里加上一个无参且不做事的构造方法。

## 14.抽象类和接口的区别
1. 接口的方法默认是public,所有方法在接口中不能有实现（Java8开始接口方法可以有默认实现），抽象类可以有非抽象的方法
2. 接口中的实例变量默认是final的，而抽象类则不一定
3. 一个类可以实现多个接口，但最多实现一个抽象类
4. 一个类实现接口的话要实现接口的所有方法，而抽象类则不一定
5. 接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象。从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

## 15.类的构造方法有什么作用？没有声明构造方法还能执行吗？
构造方法的主要作用是完成对类对象的初始化工作。

即使一个类没有声明构造方法也会有默认的无参构造方法，所以可以执行。

## 16.调用子类的构造方法之前为什么会先调用父类的无参构造方法？
帮助子类做初始化工作。

## 17.对象相等和指向它们的引用相等，两者有什么不同？
对象相等是内存中的内容相等，而引用相等，比较的是它们指向的内存地址相等。


## 18.静态方法和实例方法的区别
1. 调用静态方法不用创建对象。静态方法是属于类的，在外部调用静态方法时，可以使用类名.方法名的方式，也可以使用对象名.方法名的方式调用；实例方法只有在对象被实例化出来之后才能调用，使用对象名.方法名的方式。
2. 静态方法只能访问静态成员（即静态成员变量和静态方法），不允许访问实例成员变量和实例方法，因为静态方法在执行时不一定有实例对象被创建出来。实例方法访问成员变量无此限制。

## 19.Java是多线程编程，为什么不能多进程编程?
多进程是指操作系统能同时运行多个任务（程序），多线程是指在同一程序中有多个顺序流在执行。

java.exe运行起来就是JVM，Java程序在JVM上执行，而JVM本身就是一个进程，在进程中进行多进程编程，显然是行不通的。

## 20.Java反射机制
Java在运行状态中，对于任何一个类，都能够知道它的所有属性和方法，对于任何一个对象，都能够调用它的方法和属性，把这种动态获取信息以及动态调用对象的方法的功能称为Java的反射机制。


## 21.volatile关键字的作用
使用volatile关键字修饰的变量能够强迫线程去主存(共享内存)中对其进行读写，解决了变量在主存和本地内存的读写不一致问题。

## 22.谈谈异常
#### Java异常类层次结构图：

![](https://i.imgur.com/6OuYfDa.png)

java.lang包中的Throwable类，有两个重要的子类：Execption（异常）和Error（错误）。异常可以被程序本身处理，而错误不可以。

**Error**是程序无法处理的错误，表示运行应用程序中比较严重的问题，大多数错误与代码编写者执行的操作无关，而表示程序运行时JVM发生的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。

**Execption**是程序本身可以处理的异常，Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由Java虚拟机抛出。NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算术运算异常，一个整数除以0时，抛出该异常）和 ArrayIndexOutOfBoundsException （下标越界异常）。

#### 异常处理

- try块：用于捕获异常，可以接一个或多个catch块来处理异常，如果没有catch块，必须跟一个finally块

- finally块：无论是否捕获了异常，finally块的代码都会执行，这里通常会写一些关闭Db连接，提交事务等逻辑。当try块或catch块中有return语句时，finally语句块会先执行。

- throws:用在方法定义的时候，说明该方法可能会抛出异常

- throw:用于抛出异常，可以return，一层一层地向上抛，直到找到可以处理它的调用处。

#### Throwable类常用方法

- public string getMessage():返回异常发生时的详细信息

- public void printStackTrace():在控制台上打印Throwable对象封装的异常信息

- public string toString():返回异常发生时的简要描述

**finally块不会执行的情况：**

1. 在finally语句块中发生了异常
2. 在前面使用了System.exit()退出了程序
3. 程序所在的线程死亡（当线程run( )方法执行完或因异常退出了run( )方法时，线程死亡）
4. CPU被关闭

#### 几种常见的异常

- NullPointerException：空指针异常，操作一个null对象的方法或属性时会抛出该异常。
- OutOfMemoryError:内存异常异常，这不是程序能控制的，是指要分配的对象的内存超出了当前最大的堆内存，需要调整堆内存大小以及优化程序。
- IOException：在读写磁盘文件，网络内容时发生的一种异常。
- FileNotFoundException:IOException的子类，文件找不到的时候抛出该异常，是受检查异常，需要进行手工捕获。
- ClassNotFoundException:类找不到异常，在加载类时抛出，即在类的路径下不能加载指定类。
- ClassCastException:类转换异常，将一个不是该类的实例转换成这个类就会抛出这个异常。
- NoSuchMethodException:没有这个方法异常，一般发生在反射调用方法时，是受检查异常，需要进行手工捕获。
- IndexOutOfBoundsException：索引越界异常，当操作一个字符串或数组的时候常遇到的异常
- ArithmeticException:算数异常，数字的算术运算时的异常，比如一个数除以0。
- SQLException:SQL异常，发生在操作数据库时的异常。
- RuntimeExecption
- StringIndexOutOfBoundsException
- IllegalStateExecption
- IllegalThreadStateExecption
- NumberFormatExecption

#### Java异常类层次结构图

其中红色部分为受检查异常，它们必须被捕获，或者在函数中声明为抛出该异常。


![](https://i.imgur.com/EgctZoL.jpg)


## 23.Java的访问修饰符
- public 支持不同包，同包，本类，子孙类访问
- protected 支持同包，本类，子孙类访问
- default 支持同包，本类访问
- private 只支持本类访问


## 24.Java的基本数据类型

byte，short，int，long，char，float，double，boolean

## 25.静态变量和实例变量的区别

静态变量：独立存在的变量，只是位置放在某个类下，可以直接类名加点调用静态变量名使用。并且是项目或程序一启动运行到该类时就直接常驻内存。不需要初始化类再调用该变量。用关键字static声明。静态方法也是同样，可以直接调用。

实例变量：就是相当于该类的属性，只有对象被实例化以后才可以调用。但是该类未被再次使用，被垃圾回收器回收后，该实例也将不存在了，就是不在内存中了。

#### 区别：

1.存储区域不同：静态变量存储在静态存储区，普通变量存储在堆中；

2.静态变量与类相关，普通变量则与实例相关

3.内存分配方式不同。

4.生命周期不同。
